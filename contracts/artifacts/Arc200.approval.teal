#pragma version 10

// This TEAL was generated by TEALScript v0.84.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// arc200_name()string
*abi_route_arc200_name:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc200_name()string
	callsub arc200_name
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// arc200_name(): string[32]
//
// Returns the name of the token
//
// @returns The name of the token
arc200_name:
	proto 0 1

	// contracts\arc200.algo.ts:15
	// return 'Arc200';
	byte 0x417263323030 // "Arc200"
	retsub

// arc200_symbol()string
*abi_route_arc200_symbol:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc200_symbol()string
	callsub arc200_symbol
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// arc200_symbol(): string[8]
//
// Returns the symbol of the token
//
// @returns The symbol of the token
arc200_symbol:
	proto 0 1

	// contracts\arc200.algo.ts:25
	// return 'Arc200';
	byte 0x417263323030 // "Arc200"
	retsub

// arc200_decimals()uint8
*abi_route_arc200_decimals:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc200_decimals()uint8
	callsub arc200_decimals
	itob
	dup
	bitlen
	int 8
	<=
	assert
	extract 7 1
	concat
	log
	int 1
	return

// arc200_decimals(): uint8
//
// Returns the decimals of the token
//
// @returns The decimals of the token
arc200_decimals:
	proto 0 1

	// contracts\arc200.algo.ts:35
	// return 6 as uint8;
	int 6
	retsub

// arc200_totalSupply()uint256
*abi_route_arc200_totalSupply:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc200_totalSupply()uint256
	callsub arc200_totalSupply
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// arc200_totalSupply(): uint256
//
// Returns the total supply of the token
//
// @returns The total supply of the token
arc200_totalSupply:
	proto 0 1

	// contracts\arc200.algo.ts:45
	// return 1_000_000_000_000_000 as uint256;
	byte 0x00000000000000000000000000000000000000000000000000038d7ea4c68000
	retsub

// arc200_balanceOf(address)uint256
*abi_route_arc200_balanceOf:
	// The ABI return prefix
	byte 0x151f7c75

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc200_balanceOf(address)uint256
	callsub arc200_balanceOf
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// arc200_balanceOf(owner: Address): uint256
//
// Returns the current balance of the owner of the token
//
// @param owner The address of the owner of the token
// @returns The current balance of the holder of the token
arc200_balanceOf:
	proto 1 1

	// contracts\arc200.algo.ts:56
	// return 0 as uint256;
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	retsub

// arc200_transfer(address,uint256)bool
*abi_route_arc200_transfer:
	// The ABI return prefix
	byte 0x151f7c75

	// value: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// to: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc200_transfer(address,uint256)bool
	callsub arc200_transfer
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// arc200_transfer(to: Address, value: uint256): boolean
//
// Transfers tokens
//
// @param to The destination of the transfer
// @param value Amount of tokens to transfer
// @returns Success
arc200_transfer:
	proto 2 1

	// contracts\arc200.algo.ts:67
	// return false;
	int 0
	retsub

// arc200_transferFrom(address,address,uint256)bool
*abi_route_arc200_transferFrom:
	// The ABI return prefix
	byte 0x151f7c75

	// value: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// to: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// from: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc200_transferFrom(address,address,uint256)bool
	callsub arc200_transferFrom
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// arc200_transferFrom(from: Address, to: Address, value: uint256): boolean
//
// Transfers tokens from source to destination as approved spender
//
// @param from The source of the transfer
// @param to The destination of the transfer
// @param value Amount of tokens to transfer
// @returns Success
arc200_transferFrom:
	proto 3 1

	// contracts\arc200.algo.ts:79
	// return false;
	int 0
	retsub

// arc200_approve(address,uint256)bool
*abi_route_arc200_approve:
	// The ABI return prefix
	byte 0x151f7c75

	// value: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// spender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc200_approve(address,uint256)bool
	callsub arc200_approve
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// arc200_approve(spender: Address, value: uint256): boolean
//
// Approve spender for a token
//
// @param spender Who is allowed to take tokens on owner's behalf
// @param value Amount of tokens to be taken by spender
// @returns Success
arc200_approve:
	proto 2 1

	// contracts\arc200.algo.ts:90
	// return false;
	int 0
	retsub

// arc200_allowance(address,address)uint256
*abi_route_arc200_allowance:
	// The ABI return prefix
	byte 0x151f7c75

	// spender: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc200_allowance(address,address)uint256
	callsub arc200_allowance
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// arc200_allowance(owner: Address, spender: Address): uint256
//
// Returns the current allowance of the spender of the tokens of the owner
//
// @param owner Owner's account
// @param spender Who is allowed to take tokens on owner's behalf
// @returns The remaining allowance
arc200_allowance:
	proto 2 1

	// contracts\arc200.algo.ts:102
	// return 0 as uint256;
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication
	err

*call_NoOp:
	method "arc200_name()string"
	method "arc200_symbol()string"
	method "arc200_decimals()uint8"
	method "arc200_totalSupply()uint256"
	method "arc200_balanceOf(address)uint256"
	method "arc200_transfer(address,uint256)bool"
	method "arc200_transferFrom(address,address,uint256)bool"
	method "arc200_approve(address,uint256)bool"
	method "arc200_allowance(address,address)uint256"
	txna ApplicationArgs 0
	match *abi_route_arc200_name *abi_route_arc200_symbol *abi_route_arc200_decimals *abi_route_arc200_totalSupply *abi_route_arc200_balanceOf *abi_route_arc200_transfer *abi_route_arc200_transferFrom *abi_route_arc200_approve *abi_route_arc200_allowance
	err