#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 32 1 0 8
    bytecblock 0x151f7c75 "asa" "b" "t" 0x7983c35c 0x0000000000000000000000000000000000000000000000000000000000000000
    // contracts/arc200_asa.algo.ts:61
    // export class Arc200_ASA extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@22
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x89d9751f 0x657d13ec 0xb6ae1a25 0x84ec13d5 0xec996041 0x82e573c4 0xda7025b9 0x4a968f8f 0xb5422125 0x409b5497 0x62d41cdf 0x0223267c 0x7c02daaf 0x68cf98ce 0xbbb319f3 // method "bootstrap(byte[],byte[],uint8,uint256,(byte[32],byte[]))bool", method "arc200_name()byte[32]", method "arc200_symbol()byte[8]", method "arc200_decimals()uint8", method "arc200_totalSupply()uint256", method "arc200_balanceOf(address)uint256", method "arc200_transfer(address,uint256)bool", method "arc200_transferFrom(address,address,uint256)bool", method "arc200_approve(address,uint256)bool", method "arc200_exchange()(uint64,address)", method "arc200_redeem(uint64)void", method "deposit(uint64)uint256", method "arc200_swapBack(uint64)void", method "withdraw(uint64)uint256", method "arc200_allowance(address,address)uint256"
    txna ApplicationArgs 0
    match bootstrap arc200_name arc200_symbol arc200_decimals arc200_totalSupply arc200_balanceOf arc200_transfer arc200_transferFrom arc200_approve arc200_exchange arc200_redeem deposit arc200_swapBack withdraw arc200_allowance
    err

main___algots__.defaultCreate@22:
    // contracts/arc200_asa.algo.ts:61
    // export class Arc200_ASA extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.bootstrap[routing]() -> void:
bootstrap:
    // contracts/arc200_asa.algo.ts:91
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 4
    dup
    len
    dup
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.uint256
    txna ApplicationArgs 5
    dup
    len
    dig 1
    intc_0 // 32
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 34 // 34
    ==
    assert // invalid tail pointer at index 1 of (uint8[32],(len+uint8[]))
    dig 2
    swap
    dig 2
    substring3
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    pushint 36 // 36
    +
    uncover 2
    ==
    assert // invalid number of bytes for asaProps
    // contracts/arc200_asa.algo.ts:99
    // assert(Txn.sender === Global.creatorAddress, 'Only deployer of this smart contract can call bootstrap method')
    txn Sender
    global CreatorAddress
    ==
    assert // Only deployer of this smart contract can call bootstrap method
    // contracts/arc200_asa.algo.ts:100
    // assert(name.native.length > 0, 'Name of the asset must be longer or equal to 1 character')
    dig 6
    extract 2 0
    dup
    len
    dup
    assert // Name of the asset must be longer or equal to 1 character
    // contracts/arc200_asa.algo.ts:101
    // assert(name.native.length <= 32, 'Name of the asset must be shorter or equal to 32 characters')
    intc_0 // 32
    <=
    assert // Name of the asset must be shorter or equal to 32 characters
    // contracts/arc200_asa.algo.ts:102
    // assert(symbol.native.length > 0, 'Symbol of the asset must be longer or equal to 1 character')
    dig 6
    extract 2 0
    dup
    len
    dup
    assert // Symbol of the asset must be longer or equal to 1 character
    // contracts/arc200_asa.algo.ts:103
    // assert(symbol.native.length <= 8, 'Symbol of the asset must be shorter or equal to 8 characters')
    intc_3 // 8
    <=
    assert // Symbol of the asset must be shorter or equal to 8 characters
    // contracts/arc200_asa.algo.ts:104
    // assert(!this.totalSupply.hasValue, 'This method can be called only once')
    intc_2 // 0
    // contracts/arc200_asa.algo.ts:80
    // public totalSupply = GlobalState<Uint256>({ key: 't' })
    bytec_3 // "t"
    // contracts/arc200_asa.algo.ts:104
    // assert(!this.totalSupply.hasValue, 'This method can be called only once')
    app_global_get_ex
    bury 1
    !
    assert // This method can be called only once
    // contracts/arc200_asa.algo.ts:65
    // public name = GlobalState<DynamicBytes>({ key: 'n' })
    pushbytes "n"
    // contracts/arc200_asa.algo.ts:106
    // this.name.value = name
    uncover 9
    app_global_put
    // contracts/arc200_asa.algo.ts:70
    // public symbol = GlobalState<DynamicBytes>({ key: 's' })
    pushbytes "s"
    // contracts/arc200_asa.algo.ts:107
    // this.symbol.value = symbol
    uncover 8
    app_global_put
    // contracts/arc200_asa.algo.ts:80
    // public totalSupply = GlobalState<Uint256>({ key: 't' })
    bytec_3 // "t"
    // contracts/arc200_asa.algo.ts:108
    // this.totalSupply.value = totalSupply
    dig 6
    app_global_put
    // contracts/arc200_asa.algo.ts:75
    // public decimals = GlobalState<Uint8>({ key: 'd' })
    pushbytes "d"
    // contracts/arc200_asa.algo.ts:109
    // this.decimals.value = decimals
    dig 7
    app_global_put
    // contracts/arc200_asa.algo.ts:111
    // const sender = new Address(Txn.sender)
    txn Sender
    // contracts/arc200_asa.algo.ts:82
    // public balances = BoxMap<Address, Uint256>({ keyPrefix: 'b' })
    bytec_2 // "b"
    dig 1
    concat
    // contracts/arc200_asa.algo.ts:113
    // this.balances(sender).value = totalSupply
    dig 7
    box_put
    // contracts/arc200_asa.algo.ts:115-128
    // const createdAsset = itxn
    //   .assetConfig({
    //     total: totalSupply.asUint64(),
    //     defaultFrozen: false,
    //     unitName: symbol.native,
    //     assetName: name.native,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     fee: 0,
    //     metadataHash: asset.metadataHash.native.toFixed({ length: 32 }),
    //     url: asset.url.native,
    //     decimals: decimals.asUint64(),
    //   })
    //   .submit().createdAsset
    itxn_begin
    // contracts/arc200_asa.algo.ts:117
    // total: totalSupply.asUint64(),
    dig 6
    bitlen
    pushint 64 // 64
    <=
    assert // overflow
    uncover 5
    intc_3 // 8
    -
    dig 6
    swap
    extract_uint64
    // contracts/arc200_asa.algo.ts:121
    // manager: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/arc200_asa.algo.ts:122
    // reserve: Global.currentApplicationAddress,
    dup
    // contracts/arc200_asa.algo.ts:124
    // metadataHash: asset.metadataHash.native.toFixed({ length: 32 }),
    uncover 7
    extract 0 32
    dup
    len
    intc_0 // 32
    ==
    assert // Length must be 32
    // contracts/arc200_asa.algo.ts:125
    // url: asset.url.native,
    uncover 7
    extract 2 0
    // contracts/arc200_asa.algo.ts:126
    // decimals: decimals.asUint64(),
    uncover 9
    btoi
    itxn_field ConfigAssetDecimals
    itxn_field ConfigAssetURL
    itxn_field ConfigAssetMetadataHash
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    uncover 3
    itxn_field ConfigAssetName
    uncover 2
    itxn_field ConfigAssetUnitName
    // contracts/arc200_asa.algo.ts:118
    // defaultFrozen: false,
    intc_2 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetTotal
    // contracts/arc200_asa.algo.ts:115-127
    // const createdAsset = itxn
    //   .assetConfig({
    //     total: totalSupply.asUint64(),
    //     defaultFrozen: false,
    //     unitName: symbol.native,
    //     assetName: name.native,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     fee: 0,
    //     metadataHash: asset.metadataHash.native.toFixed({ length: 32 }),
    //     url: asset.url.native,
    //     decimals: decimals.asUint64(),
    //   })
    pushint 3 // 3
    itxn_field TypeEnum
    // contracts/arc200_asa.algo.ts:123
    // fee: 0,
    intc_2 // 0
    itxn_field Fee
    // contracts/arc200_asa.algo.ts:115-128
    // const createdAsset = itxn
    //   .assetConfig({
    //     total: totalSupply.asUint64(),
    //     defaultFrozen: false,
    //     unitName: symbol.native,
    //     assetName: name.native,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     fee: 0,
    //     metadataHash: asset.metadataHash.native.toFixed({ length: 32 }),
    //     url: asset.url.native,
    //     decimals: decimals.asUint64(),
    //   })
    //   .submit().createdAsset
    itxn_submit
    itxn CreatedAssetID
    // contracts/arc200_asa.algo.ts:130
    // this.assetId.value = new Uint64(createdAsset.id)
    itob
    // contracts/arc200_asa.algo.ts:89
    // public assetId = GlobalState<Uint64>({ key: 'asa' })
    bytec_1 // "asa"
    // contracts/arc200_asa.algo.ts:130
    // this.assetId.value = new Uint64(createdAsset.id)
    swap
    app_global_put
    // contracts/arc200_asa.algo.ts:132
    // emit(new arc200_Transfer({ from: new Address(Global.zeroAddress), to: sender, value: totalSupply }))
    global ZeroAddress
    swap
    concat
    swap
    concat
    bytec 4 // method "arc200_Transfer(address,address,uint256)"
    swap
    concat
    log
    // contracts/arc200_asa.algo.ts:91
    // @arc4.abimethod()
    pushbytes 0x151f7c7580
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_name[routing]() -> void:
arc200_name:
    // contracts/arc200_asa.algo.ts:143
    // return new StaticBytes<32>(this.name.value.native)
    intc_2 // 0
    // contracts/arc200_asa.algo.ts:65
    // public name = GlobalState<DynamicBytes>({ key: 'n' })
    pushbytes "n"
    // contracts/arc200_asa.algo.ts:143
    // return new StaticBytes<32>(this.name.value.native)
    app_global_get_ex
    assert // check GlobalState exists
    extract 2 0
    dup
    len
    intc_0 // 32
    ==
    assert // invalid size
    // contracts/arc200_asa.algo.ts:141
    // @arc4.abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_symbol[routing]() -> void:
arc200_symbol:
    // contracts/arc200_asa.algo.ts:153
    // return new StaticBytes<8>(this.symbol.value.native)
    intc_2 // 0
    // contracts/arc200_asa.algo.ts:70
    // public symbol = GlobalState<DynamicBytes>({ key: 's' })
    pushbytes "s"
    // contracts/arc200_asa.algo.ts:153
    // return new StaticBytes<8>(this.symbol.value.native)
    app_global_get_ex
    assert // check GlobalState exists
    extract 2 0
    dup
    len
    intc_3 // 8
    ==
    assert // invalid size
    // contracts/arc200_asa.algo.ts:151
    // @arc4.abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_decimals[routing]() -> void:
arc200_decimals:
    // contracts/arc200_asa.algo.ts:163
    // return this.decimals.value
    intc_2 // 0
    // contracts/arc200_asa.algo.ts:75
    // public decimals = GlobalState<Uint8>({ key: 'd' })
    pushbytes "d"
    // contracts/arc200_asa.algo.ts:163
    // return this.decimals.value
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc200_asa.algo.ts:161
    // @arc4.abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_totalSupply[routing]() -> void:
arc200_totalSupply:
    // contracts/arc200_asa.algo.ts:173
    // return this.totalSupply.value
    intc_2 // 0
    // contracts/arc200_asa.algo.ts:80
    // public totalSupply = GlobalState<Uint256>({ key: 't' })
    bytec_3 // "t"
    // contracts/arc200_asa.algo.ts:173
    // return this.totalSupply.value
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc200_asa.algo.ts:171
    // @arc4.abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_balanceOf[routing]() -> void:
arc200_balanceOf:
    // contracts/arc200_asa.algo.ts:182
    // @arc4.abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // contracts/arc200_asa.algo.ts:184
    // return this._balanceOf(owner)
    callsub _balanceOf
    // contracts/arc200_asa.algo.ts:182
    // @arc4.abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_transfer[routing]() -> void:
arc200_transfer:
    // contracts/arc200_asa.algo.ts:194
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.uint256
    // contracts/arc200_asa.algo.ts:196
    // return this._transfer(new Address(Txn.sender), to, value)
    txn Sender
    cover 2
    callsub _transfer
    // contracts/arc200_asa.algo.ts:194
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_transferFrom[routing]() -> void:
arc200_transferFrom:
    // contracts/arc200_asa.algo.ts:207
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 3
    dup
    len
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.uint256
    // contracts/arc200_asa.algo.ts:209
    // const spender = new Address(Txn.sender)
    txn Sender
    // contracts/arc200_asa.algo.ts:210
    // const spender_allowance = this._allowance(from, spender)
    dig 3
    dig 1
    callsub _allowance
    // contracts/arc200_asa.algo.ts:211
    // assert(spender_allowance.asBigUint() >= value.asBigUint(), 'insufficient approval')
    dup
    dig 3
    b>=
    assert // insufficient approval
    // contracts/arc200_asa.algo.ts:212
    // const new_spender_allowance = new Uint256(spender_allowance.asBigUint() - value.asBigUint())
    dig 2
    b-
    dup
    len
    intc_0 // 32
    <=
    assert // overflow
    intc_0 // 32
    bzero
    b|
    // contracts/arc200_asa.algo.ts:213
    // this._approve(from, spender, new_spender_allowance)
    dig 4
    cover 2
    callsub _approve
    pop
    // contracts/arc200_asa.algo.ts:214
    // return this._transfer(from, to, value)
    callsub _transfer
    // contracts/arc200_asa.algo.ts:207
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_approve[routing]() -> void:
arc200_approve:
    // contracts/arc200_asa.algo.ts:224
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.uint256
    // contracts/arc200_asa.algo.ts:226
    // const owner = new Address(Txn.sender)
    txn Sender
    // contracts/arc200_asa.algo.ts:227
    // return this._approve(owner, spender, value)
    cover 2
    callsub _approve
    // contracts/arc200_asa.algo.ts:224
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_exchange[routing]() -> void:
arc200_exchange:
    // contracts/arc200_asa.algo.ts:243
    // exchange_asset: this.assetId.value, //The ASA ID that the ARC200 token can be exchanged with.
    intc_2 // 0
    // contracts/arc200_asa.algo.ts:89
    // public assetId = GlobalState<Uint64>({ key: 'asa' })
    bytec_1 // "asa"
    // contracts/arc200_asa.algo.ts:243
    // exchange_asset: this.assetId.value, //The ASA ID that the ARC200 token can be exchanged with.
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc200_asa.algo.ts:244
    // sink: new Address(Global.currentApplicationAddress), // The address that holds ARC200 tokens for redemption operations.
    global CurrentApplicationAddress
    // contracts/arc200_asa.algo.ts:242-245
    // return new arc200_exchangeInfo({
    //   exchange_asset: this.assetId.value, //The ASA ID that the ARC200 token can be exchanged with.
    //   sink: new Address(Global.currentApplicationAddress), // The address that holds ARC200 tokens for redemption operations.
    // })
    concat
    // contracts/arc200_asa.algo.ts:240
    // @arc4.abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_redeem[routing]() -> void:
arc200_redeem:
    // contracts/arc200_asa.algo.ts:263
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // contracts/arc200_asa.algo.ts:265
    // const prev = gtxn.Transaction(Txn.groupIndex - 1)
    txn GroupIndex
    intc_1 // 1
    -
    // contracts/arc200_asa.algo.ts:266
    // assert(prev.type === TransactionType.AssetTransfer, 'Previous txn must be ASA transfer')
    gtxns TypeEnum
    pushint 4 // 4
    ==
    assert // Previous txn must be ASA transfer
    // contracts/arc200_asa.algo.ts:267
    // const axfer = gtxn.AssetTransferTxn(Txn.groupIndex - 1)
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    // contracts/arc200_asa.algo.ts:269
    // axfer.assetAmount >= amount.asUint64(),
    dup
    gtxns AssetAmount
    uncover 2
    btoi
    dig 1
    <=
    // contracts/arc200_asa.algo.ts:268-271
    // assert(
    //   axfer.assetAmount >= amount.asUint64(),
    //   'The amount transferred MUST be equal to or greater than the amount requested',
    // )
    assert // The amount transferred MUST be equal to or greater than the amount requested
    // contracts/arc200_asa.algo.ts:272
    // assert(axfer.xferAsset.id === this.assetId.value.asUint64(), 'ASA ID must match configured exchange_asset')
    dig 1
    gtxns XferAsset
    intc_2 // 0
    // contracts/arc200_asa.algo.ts:89
    // public assetId = GlobalState<Uint64>({ key: 'asa' })
    bytec_1 // "asa"
    // contracts/arc200_asa.algo.ts:272
    // assert(axfer.xferAsset.id === this.assetId.value.asUint64(), 'ASA ID must match configured exchange_asset')
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    ==
    assert // ASA ID must match configured exchange_asset
    // contracts/arc200_asa.algo.ts:273
    // assert(axfer.assetReceiver === Global.currentApplicationAddress, 'ASA must be sent to the sink address')
    dig 1
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // ASA must be sent to the sink address
    // contracts/arc200_asa.algo.ts:274
    // assert(axfer.sender === Txn.sender, 'ASA sender must match ARC200 redeemer')
    swap
    gtxns Sender
    txn Sender
    ==
    assert // ASA sender must match ARC200 redeemer
    // contracts/arc200_asa.algo.ts:277
    // new Address(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    // contracts/arc200_asa.algo.ts:278
    // new Address(Txn.sender),
    txn Sender
    // contracts/arc200_asa.algo.ts:279
    // new Uint256(axfer.assetAmount), // send the real amount which must be greater or equal to requested amount
    uncover 2
    itob
    intc_0 // 32
    bzero
    b|
    // contracts/arc200_asa.algo.ts:276-280
    // this._transfer(
    //   new Address(Global.currentApplicationAddress),
    //   new Address(Txn.sender),
    //   new Uint256(axfer.assetAmount), // send the real amount which must be greater or equal to requested amount
    // )
    callsub _transfer
    pop
    // contracts/arc200_asa.algo.ts:263
    // @arc4.abimethod()
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.deposit[routing]() -> void:
deposit:
    // contracts/arc200_asa.algo.ts:288
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // contracts/arc200_asa.algo.ts:290
    // const prev = gtxn.Transaction(Txn.groupIndex - 1)
    txn GroupIndex
    intc_1 // 1
    -
    // contracts/arc200_asa.algo.ts:291
    // assert(prev.type === TransactionType.AssetTransfer, 'Previous txn must be ASA transfer')
    gtxns TypeEnum
    pushint 4 // 4
    ==
    assert // Previous txn must be ASA transfer
    // contracts/arc200_asa.algo.ts:292
    // const axfer = gtxn.AssetTransferTxn(Txn.groupIndex - 1)
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    // contracts/arc200_asa.algo.ts:294
    // axfer.assetAmount >= amount.asUint64(),
    dup
    gtxns AssetAmount
    uncover 2
    btoi
    dig 1
    <=
    // contracts/arc200_asa.algo.ts:293-296
    // assert(
    //   axfer.assetAmount >= amount.asUint64(),
    //   'The amount transferred MUST be equal to or greater than the amount requested',
    // )
    assert // The amount transferred MUST be equal to or greater than the amount requested
    // contracts/arc200_asa.algo.ts:297
    // assert(axfer.xferAsset.id === this.assetId.value.asUint64(), 'ASA ID must match configured exchange_asset')
    dig 1
    gtxns XferAsset
    intc_2 // 0
    // contracts/arc200_asa.algo.ts:89
    // public assetId = GlobalState<Uint64>({ key: 'asa' })
    bytec_1 // "asa"
    // contracts/arc200_asa.algo.ts:297
    // assert(axfer.xferAsset.id === this.assetId.value.asUint64(), 'ASA ID must match configured exchange_asset')
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    ==
    assert // ASA ID must match configured exchange_asset
    // contracts/arc200_asa.algo.ts:298
    // assert(axfer.assetReceiver === Global.currentApplicationAddress, 'ASA must be sent to the sink address')
    dig 1
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // ASA must be sent to the sink address
    // contracts/arc200_asa.algo.ts:299
    // assert(axfer.sender === Txn.sender, 'ASA sender must match ARC200 redeemer')
    swap
    gtxns Sender
    txn Sender
    ==
    assert // ASA sender must match ARC200 redeemer
    // contracts/arc200_asa.algo.ts:300
    // const ret = new Uint256(axfer.assetAmount)
    itob
    intc_0 // 32
    bzero
    b|
    // contracts/arc200_asa.algo.ts:302
    // new Address(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    // contracts/arc200_asa.algo.ts:303
    // new Address(Txn.sender),
    txn Sender
    // contracts/arc200_asa.algo.ts:301-305
    // this._transfer(
    //   new Address(Global.currentApplicationAddress),
    //   new Address(Txn.sender),
    //   ret, // send the real amount which must be greater or equal to requested amount
    // )
    dig 2
    callsub _transfer
    pop
    // contracts/arc200_asa.algo.ts:288
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_swapBack[routing]() -> void:
arc200_swapBack:
    // contracts/arc200_asa.algo.ts:324
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    dup
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // contracts/arc200_asa.algo.ts:327
    // new Address(Txn.sender),
    txn Sender
    // contracts/arc200_asa.algo.ts:328
    // new Address(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    // contracts/arc200_asa.algo.ts:329
    // new Uint256(amount.asBigUint()),
    uncover 2
    intc_0 // 32
    <=
    assert // overflow
    intc_0 // 32
    bzero
    dig 3
    b|
    // contracts/arc200_asa.algo.ts:326-330
    // this._transfer(
    //   new Address(Txn.sender),
    //   new Address(Global.currentApplicationAddress),
    //   new Uint256(amount.asBigUint()),
    // )
    callsub _transfer
    pop
    // contracts/arc200_asa.algo.ts:331-338
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount.asUint64(),
    //     xferAsset: this.assetId.value.asUint64(),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // contracts/arc200_asa.algo.ts:333
    // assetReceiver: Txn.sender,
    txn Sender
    // contracts/arc200_asa.algo.ts:334
    // assetAmount: amount.asUint64(),
    swap
    btoi
    // contracts/arc200_asa.algo.ts:335
    // xferAsset: this.assetId.value.asUint64(),
    intc_2 // 0
    // contracts/arc200_asa.algo.ts:89
    // public assetId = GlobalState<Uint64>({ key: 'asa' })
    bytec_1 // "asa"
    // contracts/arc200_asa.algo.ts:335
    // xferAsset: this.assetId.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    itxn_field XferAsset
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // contracts/arc200_asa.algo.ts:331-337
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount.asUint64(),
    //     xferAsset: this.assetId.value.asUint64(),
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // contracts/arc200_asa.algo.ts:336
    // fee: 0,
    intc_2 // 0
    itxn_field Fee
    // contracts/arc200_asa.algo.ts:331-338
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount.asUint64(),
    //     xferAsset: this.assetId.value.asUint64(),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // contracts/arc200_asa.algo.ts:324
    // @arc4.abimethod()
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.withdraw[routing]() -> void:
withdraw:
    // contracts/arc200_asa.algo.ts:346
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    dup
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // contracts/arc200_asa.algo.ts:348
    // const ret = new Uint256(amount.asBigUint())
    intc_0 // 32
    <=
    assert // overflow
    intc_0 // 32
    bzero
    dig 1
    b|
    // contracts/arc200_asa.algo.ts:349
    // this._transfer(new Address(Txn.sender), new Address(Global.currentApplicationAddress), ret)
    txn Sender
    global CurrentApplicationAddress
    dig 2
    callsub _transfer
    pop
    // contracts/arc200_asa.algo.ts:350-357
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount.asUint64(),
    //     xferAsset: this.assetId.value.asUint64(),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // contracts/arc200_asa.algo.ts:352
    // assetReceiver: Txn.sender,
    txn Sender
    // contracts/arc200_asa.algo.ts:353
    // assetAmount: amount.asUint64(),
    uncover 2
    btoi
    // contracts/arc200_asa.algo.ts:354
    // xferAsset: this.assetId.value.asUint64(),
    intc_2 // 0
    // contracts/arc200_asa.algo.ts:89
    // public assetId = GlobalState<Uint64>({ key: 'asa' })
    bytec_1 // "asa"
    // contracts/arc200_asa.algo.ts:354
    // xferAsset: this.assetId.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    itxn_field XferAsset
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // contracts/arc200_asa.algo.ts:350-356
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount.asUint64(),
    //     xferAsset: this.assetId.value.asUint64(),
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // contracts/arc200_asa.algo.ts:355
    // fee: 0,
    intc_2 // 0
    itxn_field Fee
    // contracts/arc200_asa.algo.ts:350-357
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount.asUint64(),
    //     xferAsset: this.assetId.value.asUint64(),
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // contracts/arc200_asa.algo.ts:346
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA.arc200_allowance[routing]() -> void:
arc200_allowance:
    // contracts/arc200_asa.algo.ts:367
    // @arc4.abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // contracts/arc200_asa.algo.ts:369
    // return this._allowance(owner, spender)
    callsub _allowance
    // contracts/arc200_asa.algo.ts:367
    // @arc4.abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/arc200_asa.algo.ts::Arc200_ASA._balanceOf(owner: bytes) -> bytes:
_balanceOf:
    // contracts/arc200_asa.algo.ts:372
    // private _balanceOf(owner: Address): Uint256 {
    proto 1 1
    // contracts/arc200_asa.algo.ts:82
    // public balances = BoxMap<Address, Uint256>({ keyPrefix: 'b' })
    bytec_2 // "b"
    frame_dig -1
    concat
    dup
    // contracts/arc200_asa.algo.ts:373
    // if (!this.balances(owner).exists) return new Uint256(0)
    box_len
    bury 1
    bnz _balanceOf_after_if_else@2
    bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub

_balanceOf_after_if_else@2:
    // contracts/arc200_asa.algo.ts:374
    // return this.balances(owner).value
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub


// contracts/arc200_asa.algo.ts::Arc200_ASA._transfer(sender: bytes, recipient: bytes, amount: bytes) -> bytes:
_transfer:
    // contracts/arc200_asa.algo.ts:377
    // private _transfer(sender: Address, recipient: Address, amount: Uint256): Bool {
    proto 3 1
    // contracts/arc200_asa.algo.ts:378
    // const sender_balance = this._balanceOf(sender)
    frame_dig -3
    callsub _balanceOf
    dup
    // contracts/arc200_asa.algo.ts:379
    // const recipient_balance = this._balanceOf(recipient)
    frame_dig -2
    callsub _balanceOf
    swap
    // contracts/arc200_asa.algo.ts:380
    // assert(sender_balance.asBigUint() >= amount.asBigUint(), 'Insufficient balance at the sender account')
    frame_dig -1
    b>=
    assert // Insufficient balance at the sender account
    // contracts/arc200_asa.algo.ts:382
    // if (sender !== recipient) {
    frame_dig -3
    frame_dig -2
    !=
    bz _transfer_after_if_else@2
    // contracts/arc200_asa.algo.ts:384
    // this.balances(sender).value = new Uint256(sender_balance.asBigUint() - amount.asBigUint())
    frame_dig 0
    frame_dig -1
    b-
    dup
    len
    intc_0 // 32
    <=
    assert // overflow
    intc_0 // 32
    bzero
    swap
    dig 1
    b|
    // contracts/arc200_asa.algo.ts:82
    // public balances = BoxMap<Address, Uint256>({ keyPrefix: 'b' })
    bytec_2 // "b"
    frame_dig -3
    concat
    // contracts/arc200_asa.algo.ts:384
    // this.balances(sender).value = new Uint256(sender_balance.asBigUint() - amount.asBigUint())
    swap
    box_put
    // contracts/arc200_asa.algo.ts:385
    // this.balances(recipient).value = new Uint256(recipient_balance.asBigUint() + amount.asBigUint())
    frame_dig 1
    frame_dig -1
    b+
    dup
    len
    intc_0 // 32
    <=
    assert // overflow
    b|
    // contracts/arc200_asa.algo.ts:82
    // public balances = BoxMap<Address, Uint256>({ keyPrefix: 'b' })
    bytec_2 // "b"
    frame_dig -2
    concat
    // contracts/arc200_asa.algo.ts:385
    // this.balances(recipient).value = new Uint256(recipient_balance.asBigUint() + amount.asBigUint())
    swap
    box_put

_transfer_after_if_else@2:
    // contracts/arc200_asa.algo.ts:387
    // emit(new arc200_Transfer({ from: sender, to: recipient, value: amount }))
    frame_dig -3
    frame_dig -2
    concat
    frame_dig -1
    concat
    bytec 4 // method "arc200_Transfer(address,address,uint256)"
    swap
    concat
    log
    // contracts/arc200_asa.algo.ts:388
    // return new Bool(true)
    pushbytes 0x80
    frame_bury 0
    retsub


// contracts/arc200_asa.algo.ts::Arc200_ASA._allowance(owner: bytes, spender: bytes) -> bytes:
_allowance:
    // contracts/arc200_asa.algo.ts:395
    // private _allowance(owner: Address, spender: Address): Uint256 {
    proto 2 1
    // contracts/arc200_asa.algo.ts:392
    // return new StaticBytes<32>(op.sha256(op.concat(owner.bytes, spender.bytes)))
    frame_dig -2
    frame_dig -1
    concat
    sha256
    // contracts/arc200_asa.algo.ts:84
    // public approvals = BoxMap<StaticBytes<32>, ApprovalStruct>({ keyPrefix: 'a' })
    pushbytes "a"
    swap
    concat
    dup
    // contracts/arc200_asa.algo.ts:397
    // if (!this.approvals(key).exists) return new Uint256(0)
    box_len
    bury 1
    bnz _allowance_after_if_else@2
    bytec 5 // 0x0000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub

_allowance_after_if_else@2:
    // contracts/arc200_asa.algo.ts:398
    // return this.approvals(key).value.approvalAmount
    frame_dig 0
    box_get
    assert // Box must have value
    extract 0 32
    swap
    retsub


// contracts/arc200_asa.algo.ts::Arc200_ASA._approve(owner: bytes, spender: bytes, amount: bytes) -> bytes:
_approve:
    // contracts/arc200_asa.algo.ts:401
    // private _approve(owner: Address, spender: Address, amount: Uint256): Bool {
    proto 3 1
    // contracts/arc200_asa.algo.ts:392
    // return new StaticBytes<32>(op.sha256(op.concat(owner.bytes, spender.bytes)))
    frame_dig -3
    frame_dig -2
    concat
    dup
    sha256
    // contracts/arc200_asa.algo.ts:403-407
    // const approvalBox: ApprovalStruct = new ApprovalStruct({
    //   approvalAmount: amount,
    //   owner: owner,
    //   spender: spender,
    // })
    frame_dig -1
    frame_dig -3
    concat
    frame_dig -2
    concat
    // contracts/arc200_asa.algo.ts:84
    // public approvals = BoxMap<StaticBytes<32>, ApprovalStruct>({ keyPrefix: 'a' })
    pushbytes "a"
    uncover 2
    concat
    // contracts/arc200_asa.algo.ts:408
    // this.approvals(key).value = clone(approvalBox)
    swap
    box_put
    // contracts/arc200_asa.algo.ts:409
    // emit(new arc200_Approval({ owner: owner, spender: spender, value: amount }))
    frame_dig -1
    concat
    pushbytes 0x1969f865 // method "arc200_Approval(address,address,uint256)"
    swap
    concat
    log
    // contracts/arc200_asa.algo.ts:410
    // return new Bool(true)
    pushbytes 0x80
    retsub
